= android-commons
:toc: macro
:sectnums:
:toclevels: 1
:doctype: book

Libraries written in Kotlin and used in most EL Passion Android projects.

image:https://jitpack.io/v/elpassion/android-commons.svg[https://jitpack.io/#elpassion/android-commons]

== Overview

In EL Passion we believe that every library should be as small as possible, and do one thing, but do
it well.

That's why we follow highly modularized approach.

toc::[]

=== Building with JitPack

[source,groovy]
----
repositories {
    maven { url "https://jitpack.io" }
}
----
Details: https://jitpack.io/#elpassion/android-commons

== Espresso

Espresso module contains useful stuff when writing tests using espresso framework.

For example instead of writing
[source,java]
----
    Espresso.onView(ViewMatchers.withId(R.id.button))
    .check(ViewAssertions.matches(ViewMatchers.isDisplayed()))
----
Leveraging the kotlin expressiveness we can write:
[source,kotlin]
----
include::espresso/src/androidTest/java/com/elpassion/android/commons/espresso/OnIdTest.kt[tags=espresso-on-id-test]
----

=== Download:
[source,groovy]
----
    androidTestImplementation "com.github.elpassion.android-commons:espresso:0.0.22"
----
Back to <<Overview>>

== RxJava2-test

RxJava2-test module basically contains two things.

. Set of extension methods useful when stubbing api

+
For example instead of writing:

+
[source,kotlin]
----
    whenever(api.makeRequest()).thenReturn(Completable.error(RuntimeException()))
----

+
We can write:

+
[source,kotlin]
----
include::rxjava2-test/src/test/java/com/elpassion/android/commons/rxjava2/test/StubbingSingleExtensionTest.kt[tags=rxjava2-then-error]
----

+
There are corresponding methods for Observable, and Single classes as well.

. Set of assertions for testObservers

    * assertValueThat
+
[source,kotlin]
----
include::rxjava2-test/src/test/java/com/elpassion/android/commons/rxjava2/test/AssertableSubscriberExtensionTest.kt[tags=rxjava2-assertValueThat]
----

    * assertValuesThat
+
[source,kotlin]
----
include::rxjava2-test/src/test/java/com/elpassion/android/commons/rxjava2/test/AssertableSubscriberExtensionTest.kt[tags=rxjava2-assertValuesThat]
----

    * assertLastValueThat
+
[source,kotlin]
----
include::shared-preferences/src/main/java/com/elpassion/android/commons/sharedpreferences/SharedPreferenceRepository.kt[tags=sharedpreferences-interface]
----


=== Download:
[source,groovy]
----
    androidTestImplementation "com.github.elpassion.android-commons:rxjava-test:0.0.22"
----
Back to <<Overview>>

== SharedPreferences

This is a core module which provides an abstraction over android shared preferences.

[source,kotlin]
----
include::shared-preferences/src/main/java/com/elpassion/android/commons/sharedpreferences/SharedPreferenceRepository.kt[tags=sharedpreferences-interface]
----

To create an instance of it use the factory method:

[source,kotlin]
----
include::shared-preferences-gson-converter-adapter/src/androidTest/java/com/elpassion/sharedpreferences/gsonadapter/SharedPreferencesTestCase.kt[tags=sharedpreferences-create-shared-prefs]
----

A JsonAdapter is a class which fulfills following contract:

[source,kotlin]
----
include::shared-preferences/src/main/java/com/elpassion/android/commons/sharedpreferences/JsonConverterAdapter.kt[tags=sharedpreferences-json-converter-adapter-interface]
----
As you see any class that can serialize objects to strings and later deserialize them will do.

We have created two adapters for the most commonly used serialization libraries:

. <<SharedPreferences-Moshi>>
. <<SharedPreferences-Gson>>

There is also an extension method which binds any field into specific key from shared preferences
[source,kotlin]
----
    var token: String? by sharedPreferences.asProperty(key = "authToken")
----
or you can use its non-nullable variant
[source,kotlin]
----
    var token: String by sharedPreferences.asPropertyWithDefault(key = "authToken", default = "invalid")
----

If you are reading very often we suggest you to wrap your sharedPreferences instance with CachingSharedPreferences wrapper.
It uses the same interface so it is transparent from the usage perspective. Keep in mind that in order to cache values and
properly invalidate them, every interactions with sharedPreferences must now go through the same instance of the caching wrapper.

=== Download:
[source,groovy]
----
    implementation "com.github.elpassion.android-commons:shared-preferences:0.0.22"
----
Back to <<Overview>>

== SharedPreferences-Moshi

It is a moshi adapter for our sharedPreferences library.

To create an instance of it use a factory function:
[source,kotlin]
----
    moshiConverterAdapter(moshi = instanceOfMoshi)
----

=== Download:
[source,kotlin]
----
    implementation "com.github.elpassion.android-commons:shared-preferences-moshi-converter-adapter:0.0.22"
----
Back to <<Overview>>

== SharedPreferences-Gson

It is a gson adapter for our sharedPreferences library.

To create an instance of it use a factory function:
[source,kotlin]
----
    gsonConverterAdapter(gson = instanceOfGson)
----

=== Download:
[source,kotlin]
----
    implementation "com.github.elpassion.android-commons:shared-preferences-gson-converter-adapter:0.0.22"
----
Back to <<Overview>>

== View

=== Download:
[source,kotlin]
----
    implementation "com.github.elpassion.android-commons:view:0.0.22"
----
Back to <<Overview>>

== Pager

=== Download:
[source,kotlin]
----
    implementation "com.github.elpassion.android-commons:pager:0.0.22"
----
Back to <<Overview>>

== Recycler

Using recycler-view have never been easier.

If all of your views are going to be the same type you can just write
[source,kotlin]
----
items = /* list of your items */
recyclerView.adapter = basicAdapterWithLayoutAndBinder(items, R.layout.my_item_layout) { holder, item ->
            holder.itemView.myTextView.text = item.name
        }
----
If you want to get benefits of using stableIds all you need to do is to make your item
implement `WithStableId` interface and of course tell the adapter to use stable ids:
`adapter.setHasStableId(true)`

On the other hand if you need to have different views for different types of items you just need to write
[source,kotlin]
----
items = /* list of your items */
recyclerView.adapter = basicAdapterWithConstructors(items) { position ->
            positionToLayoutMapping(position)
        }

private fun positionToLayoutMapping(position) = when (position) {
    isOdd() -> R.layout.github_item to ::SimpleUserViewHolder
    isEven() -> R.layout.other_github_item to ::OtherSimpleUserViewHolder
}
----
Where a view holder may look like this
[source,kotlin]
----
class SimpleUserViewHolder(itemView: View) : ViewHolderBinder<User>(itemView) {

    override fun bind(item: User) {
        itemView.userName.text = item.name
        itemView.organization.text = item.organization
    }
}
----

Dividing your data set into logical pieces is supported by `ListWithSections` class.
Here is an example:
[source,kotlin]
----
val users = createManyUsers().groupBy(User::organization).asBasicListWithSections()
recyclerView.adapter = basicAdapterWithLayoutAndBinder(users, R.layout.github_item) { holder, user ->
    with(holder.itemView) {
        userName.text = user.name
        organization.text = user.organization
    }
}
----
There is also a mutable equivalent of this class `ListWithMutableSections`.
With use of it you can e.g. clear all section at once
[source,kotlin]
----
    users.sections["Organization 1"]!!.clear()
    adapter.notifyDataSetChanged()
----

=== Download:
[source,groovy]
----
    implementation "com.github.elpassion.android-commons:recycler:0.0.22"
----
Back to <<Overview>>